# musicpy的基本语法（三）

### 在基本语法的第三章继续为大家讲解其他的音符，和弦，音阶类型的一些语法，以及介绍在写有多个声部和多个乐器的曲子时需要用到的一个新的数据类型：piece类型（乐曲类型）。

## 目录
  - [对一个和弦内的音符按照索引值提取，包括高八度和低八度的音符变换](#对一个和弦内的音符按照索引值提取包括高八度和低八度的音符变换)
  - [构建一套和弦处理规则，适用于任何和弦类型](#构建一套和弦处理规则适用于任何和弦类型)
  - [查看一个和弦类型的音符间隔列表和音符长度列表](#查看一个和弦类型的音符间隔列表和音符长度列表)
  - [查看一个和弦类型的音符音量列表](#查看一个和弦类型的音符音量列表)
  - [piece类型（乐曲类型），用来处理多个音轨以及每个音轨有自己的乐器的曲子](#"piece类型（乐曲类型），用来处理多个音轨以及每个音轨有自己的乐器的曲子")


## 对一个和弦内的音符按照索引值提取，包括高八度和低八度的音符变换

比如现在和弦A是C大三和弦，构成音为C5, E5, G5,我们想得到一串阿尔贝蒂低音，也就是把一个三和弦按照根音，五度音，三度音，五度音交替的形式演奏的左手琶音伴奏型，我们现在想要得到的是C5, G5, E5, G5, C6, G5, E5, G5这一串音符（并且放在一个和弦类型里），请注意第5个音是C6，比根音高了一个八度，这串音符是很典型的阿尔贝蒂低音的左手琶音伴奏型。使用和弦类型的get函数可以很方便地从和弦A提取这串音符。

```python
A.get([1, 3, 2, 3, 1.1, 3, 2, 3])
```

得到的结果是

```python
[C5, G5, E5, G5, C6, G5, E5, G5] with interval [0, 0, 0, 0, 0, 0, 0, 0]
```

这里的1, 2, 3表示的是和弦A里的第几个音，1.1这种小数表示的是第几个音（小数点前的数字）升高几个八度（小数点后的数字）。

如果想要某个音降低几个八度，那么只需要写负数的小数即可，比如-2.1表示把第二个音降低一个八度后的音。

进阶写法：

```python
A @ [1, 3, 2, 3, 1.1, 3, 2, 3]
```

## 构建一套和弦处理规则，适用于任何和弦类型

最简单的方法是使用python自带的lambda函数的语法，比如：

```python
rules = lambda x: C(x) @ [1, 2, 3, 1.1, 2.1, 3, 1.1, 2.1] % (1/8, 1/8) * 2
```
现在rules是一个和弦处理规则（作为函数来使用），可以输入和弦名，然后把这个和弦按照第1个音，第2个音，第三个音，第1个音高1个八度，第二个音高1个八度， 第三个音，第1个音高1个八度，第二个音高1个八度的顺序组成一个新的和弦类型（一段和弦伴奏），然后把这段和弦伴奏的每个音符的长度都设置为0.5个小节，每个音符的间隔也都设置为0.5个小节，然后把这段和弦伴奏重复两遍。

```python
A = rules('Cmajor') | rules('C7sus4') | rules('G7/B') - octave | rules('Cmajor')
```

现在我们可以用和弦处理规则rules去对C大三和弦，C属七挂四和弦，G属七和弦/B，C大三和弦来进行处理，然后通过'|'符号连接，形成一段小曲子。

以115的BPM（曲速）播放曲子片段A

```python
play(A, 115)
```

除了可以使用python自带的lambda函数，也可以使用musicpy里面的函数exp来实现构建和弦规则。

exp函数有两个模式，'tail'和'whole'，在tail模式中，传入的是一个接在一个和弦类型之后的处理规则，比如

```python
rules = exp('up(2).reverse()', mode='tail')
```

此时rules就是把一个和弦类型整体升高两个半音，然后把音倒序排列。rules本身是一个函数，可以直接把和弦类型传进去，比如

```python
rules(C('Dmaj7'))
```

在whole模式中，只需要写和lambda函数的表达式一样的内容即可，参数obj_name是lambda变量的名字，默认值为'x',比如：

```python
rules = exp('(x / 1) % ([1/4, 1/2, 1/2], [1/4, 1/4, 1/2])', mode='whole')
```

此时rules是一个和弦处理规则（是一个可以直接传入和弦类型的函数），得到一个和弦类型的第1转位，然后把和弦的音符长度分别设置为1/4, 1/2, 1/2（单位为小节），

音符间隔分别设置为1/4, 1/4, 1/2（单位为小节）。

使用lambda函数来表达就是

```python
rules = lambda x: (x / 1) % ([1/4, 1/2, 1/2], [1/4, 1/4, 1/2])
```

## 查看一个和弦类型的音符间隔列表和音符长度列表
```python
a = C('Dmaj7')
# 查看一个和弦类型的音符间隔列表
>>> print(a.interval)
[0, 0, 0, 0]

# 查看一个和弦类型的音符长度列表
>>> print(a.get_duration())
[0.25, 0.25, 0.25, 0.25]
```

## 查看一个和弦类型的音符音量列表
```python
a = C('Dmaj7')
a.setvolume([80,80,100,100])
# 查看一个和弦类型的音符音量列表
>>> print(a.get_volume())
[80, 80, 100, 100]
```

## piece类型（乐曲类型），用来处理多个音轨以及每个音轨有自己的乐器的曲子

比如说你现在想写一首曲子，这首曲子分为四个声部，主旋律（乐器：钢琴），低音（乐器：电贝斯），和弦音和装饰音（乐器：竖琴），鼓点（乐器：架子鼓），

这样你有四个乐器，分别负责四个不同的音轨，组成一首完整的曲子。而且这四个音轨都有各自的开始时间（单位为小节）。

现在比如你已经为这个四个声部写完各自的旋律了，都存储在各自的和弦类型中，比如叫做C1, C2, C3, C4。

你想要这首曲子的BPM（曲速）为150，然后四个声部分别的开始时间为0, 2, 2, 4 (单位为小节)， 0的意思就是从曲子的最开头就开始。

乐曲类型的乐器部分是对应General Midi的0 ~ 127号乐器，可以直接输入0 ~ 127的数字选择对应的乐器，也可以输入乐器的名字。

关于General Midi的128个乐器的名称和数字对应的字典可以到database.py这个文件里查看。

乐曲类型的构成（按照先后顺序）为：

```python
piece(tracks,
      instruments_list=None,
      bpm=120,
      start_times=None,
      track_names=None,
      channels=None,
      name=None,
      pan=None,
      volume=None,
      other_messages=[],
      sampler_channels=None)
```

* tracks: 每个音轨的和弦类型的列表

* instruments_list: 每个音轨的乐器的列表（可以留空不写）

* bpm: 曲速（BPM）（可以留空不写，默认为120）

* start_times: 每个音轨的开始时间的列表（单位为小节）（可以留空不写）

* track_names: 每个音轨的名字（可以留空不写）

* channels: 每个音轨对应的通道编号的列表，以0作为第1个音轨（可以留空不写）

* name: 乐曲的名字（可以留空不写）

* pan: 每个音轨的左右声道混音位置的列表（可以留空不写）

* volume: 每个音轨的整体音量大小的列表（可以留空不写）

* other_messages: 乐曲的其他的midi信息(可支持的类型请看基础语法(八))（可以留空不写）

* sampler_channels: 在sampler模块里用来指明每个音轨对应的sampler的通道编号（可以留空不写）

按照我们现在的要求，可以这样构建一个乐曲类型：
```python
C1 = chord('G4, D5, B5, F#5') % (1, 1/8) % 4
C2 = (chord('C2, C2, G1, G1') % (1,1)) % 2
C3 = (chord('F#6, G6') % (1/8, 1/8) % 8 | chord('A5, B5') % (1/8, 1/8) % 8) % 2
C4 = chord('G3, G3, G3, G3') % ([3/8,1/8,1/4,1/4], [3/8,1/8,1/4,1/4]) % 4

new_piece = piece(tracks=[C1, C2, C3, C4],
                  instruments_list=['Acoustic Grand Piano', 'Electric Bass (finger)', 'Orchestral Harp', 'Synth Drum'],
                  bpm=120,
                  start_times=[0, 2, 2, 6],
                  track_names=['piano', 'bass', 'harp', 'drum'])

>>> new_piece
[piece] 
BPM: 120
track 1 piano | instrument: Acoustic Grand Piano | start time: 0 | [G4, D5, B5, F#5, G4, D5, B5, F#5, G4, D5, B5, F#5, G4, D5, B5, F#5] with interval [0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125]
track 2 bass | instrument: Electric Bass (finger) | start time: 2 | [C2, C2, G1, G1, C2, C2, G1, G1] with interval [1, 1, 1, 1, 1, 1, 1, 1]
track 3 harp | instrument: Orchestral Harp | start time: 2 | [F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, F#6, G6, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5, A5, B5] with interval [0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125]
track 4 drum | instrument: Synth Drum | start time: 6 | [G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3, G3] with interval [0.375, 0.125, 0.25, 0.25, 0.375, 0.125, 0.25, 0.25, 0.375, 0.125, 0.25, 0.25, 0.375, 0.125, 0.25, 0.25]
```
其中如果有鼓点的轨道，可以让对应channel为9，这样乐器就可以选择General Midi中专门的鼓的类型了，比如Standard, Room, Electronic等等。

乐器的数字为1的时候是Standard的鼓组（当对应的channel为9的时候）。

现在new_piece就是一个乐器类型了，它存储着我们想要的乐曲的信息，四个轨道的名字分别叫做piano, bass, harp, drum。

要写入这首乐曲到midi文件，只需要

```python
play(new_piece)
# 或者
new_piece.play()
```

即可，play函数是写入midi文件之后直接播放，可以马上听到乐曲，如果只是写入midi文件不播放，那么就写

```python
write(new_piece, name=你想要的midi文件名)
```

play和write函数会检查你传入的是不是乐曲类型，如果是，那么就会把乐曲类型的完整信息写入midi文件，也就是每一个声部写入一个独立的轨道，每个轨道有自己独立的乐器，有自己的起始时间，有自己的名字（如果有给的话），每个轨道的通道也会对应你给的channel（如果有给的话）。因此写入的midi文件就是一首完整的有多个乐器和声部的乐曲了。

```python
piece(...)的简化写法是
P(...)
```
## 下一章 [musicpy的基本语法（四）](https://github.com/Rainbow-Dreamer/musicpy/wiki/musicpy的基本语法（四）)

