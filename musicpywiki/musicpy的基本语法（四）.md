# musicpy的基本语法（四）

## 这一部分我会讲一些最近一两个月新加入的语法特性（现在打字的日期：2020/12/28）
## 目录
  - [chord函数可以解析音符的字符串](#chord函数可以解析音符的字符串)
  - [toNote函数现在可以解析没有指定音高数的音名字符串](#toNote函数现在可以解析没有指定音高数的音名字符串)
  - [如何构建一个空和弦](#如何构建一个空和弦)
  - [音符设定长度和音量的高级语法（2020年12月新加入的语法特性）](#"音符设定长度和音量的高级语法（2020年12月新加入的语法特性）")
  - [和弦设定音符长度和音符间隔以及音符音量的高级语法（2020年12月新加入的语法特性）](#"和弦设定音符长度和音符间隔以及音符音量的高级语法（2020年12月新加入的语法特性）")
  - [play函数在选择乐器的时候可以用简写](#play函数在选择乐器的时候可以用简写)
  - [构建乐曲类型可以使用另一种语法，相对更直观一点](#构建乐曲类型可以使用另一种语法相对更直观一点)
  - [得到一个音阶的所有音按照标准音名标记法的列表](#得到一个音阶的所有音按照标准音名标记法的列表)
  - [得到一段音乐的关于一个调式的负面和声](#得到一段音乐的关于一个调式的负面和声)
  - [得到一段音乐的逆行(retrograde)与反行(inversion)](#得到一段音乐的逆行retrograde与反行inversion)


## chord函数可以解析音符的字符串
比如现在我们想要一个C大七和弦，以C5为根音，那么可以写
```python
chord('C5, E5, G5, B5')
```
或者
```python
chord('C, E, G, B', rootpitch=5)
```
rootpitch的值默认为4，所以如果想要以C4为根音的C大七和弦，可以直接写
```python
chord('C, E, G, B')
```
chord函数可以接收完全不带音高数的音名的字符串，并且按照standardize函数的标准来进行标准化和弦输出，
也就是会按照字符串中音名的先后顺序排好音符的音高，然后组成原位和弦，比如
```python
chord('C, E, G, B, D')
```
会得到
```python
[C4, E4, G4, B4, D5] with interval [0, 0, 0, 0, 0]
```
chord函数既可以接收音名组成的字符串，也可以接收由音名字符串组成的列表，比如
```python
chord(['C', 'E', 'G', 'B', 'D'])
```
会得到
```python
[C4, E4, G4, B4, D5] with interval [0, 0, 0, 0, 0]
```
当然，最直接的还是接收音符类型的列表，比如
```python
chord([N('C'), N('E'), N('G'), N('B'), N('D')])
```
不过需要注意的是，如果chord函数接收的是音符类型或者有确定音高数的音名的字符串的列表，  
那么就不会进行和弦标准化的操作，因为此时所有音符的音高数都是确定的了。  
如果想要在chord函数接收字符串的时候不进行和弦标准化的操作，那么可以手动指定音符的音高数，比如
```python
chord(['C4', 'E4', 'G4', 'B4', 'D4'])
```
或者
```python
chord('C4, E4, G4, B4, D4')
```
另外，chord函数可以接收没有指定音高数的音符和指定了音高数的音符混合使用的字符串或者字符串的列表。

## toNote函数现在可以解析没有指定音高数的音名字符串
之前toNote函数（或者用N函数也可以）接收的表示音名的字符串必须指定音高数，比如
```python
N('C5')
```
现在经过我的改进，大家可以输入没有指定音高数的表示音名的字符串，然后可以使用pitch参数指定音高数，
pitch的默认值为4，可以选择设定或者不设定，比如
```python
N('B')
```
会得到B4这个音符类型，
```python
N('B5')
```
和
```python
N('B', pitch=5)
```
都会得到B5这个音符类型。

## 如何构建一个空和弦
如果想要构建一个什么音符都没有的空和弦，可以写
```python
chord([])
```
会得到
```python
[] with interval []
```
空和弦可以作为循环添加新的和弦的初始化和弦，也可以作为一个和弦类型当做曲子来看待的时候（可以往里面添加新的旋律或者和弦的音符）的初始化和弦,比如
```python
chord([]) | C('Am') | C('F') | C('G')
```

## 音符设定长度和音量的高级语法（2020年12月新加入的语法特性）
在使用toNote函数或者N函数的时候，可以把音符的长度和音量用一种新的语法写在字符串中，
比如现在我们想要一个音符长度为1，音量为80的C5的音符类型，那么可以写
```python
N('C5(1;80)')
```
如果只想设定音符长度，那么可以写
```python
N('C5(1)')
```
请注意，分隔括号内的参数的符号必须是`;`，
然后括号可以是小括号()，中括号[]，大括号{}中的任意一种，比如
```python
N('C5(1;80)')
```
也可以写成
```python
N('C5[1;80]')
```
或者
```python
N('C5{1;80}')
```
除了音名之后的左括号必须紧靠着音名之外，括号里面的参数之间都可以有空格。
音符长度和音量可以是整数，小数或者分数。在这里我还加了一个语法糖，如果是想输入比如说2分音符，4分音符，8分音符，16分音符这样的音符，
那么可以写`.n`表示n分音符，也就是等价于1/n的音符长度。如果是比如3/4这样的音符长度，那么就可以直接写3/4，因为toNote函数是支持分数表示的。
比如现在我们想要一个D5的4分音符，音量不设定（默认为100），那么可以写
```python
N('D5(.4)')
```
此外，也支持不指定音高的表示音名的字符串后面跟着这些设定参数，具体的音高数可以用pitch指定，pitch的默认值为4，比如
```python
N('D(.4)', pitch=5)
```
会得到音符类型D5，音符长度为1/4个小节（4分音符）

## 和弦设定音符长度和音符间隔以及音符音量的高级语法（2020年12月新加入的语法特性）
在使用chord函数的时候，在写音名的字符串或者音名字符串组成的列表的时候，可以把音符的长度和音符间隔还有音量用一种新的语法写在字符串中，
比如现在我们想要写一段旋律
```python
example = chord('G5, F5, E5, F5, E5, D5, E5, D5, C5, B4, G4')
```
这段旋律的音符长度的列表为
```python
example_duration = [3/4, 1/8, 1/8, 3/4, 1/8, 1/8, 1/4, 1/4, 1/2, 1/2, 1/2]
```
这段旋律的音符间隔的列表和音符长度的列表相同，
```python
example_interval = example_duration.copy()
```
如果是传统的做法是
```python
example % (example_duration, example_interval)
```
使用新的语法可以写成
```python
example = chord('G5[3/4;3/4], F5[.8;.8], E5[.8;.8], F5[3/4;3/4], E5[.8;.8], D5[.8;.8], E5[.4;.4], D5[.4;.4], C5[.2;.2], B4[.2;.2], G4[.2;.2]')
>>> example
[G5, F5, E5, F5, E5, D5, E5, D5, C5, B4, G4] with interval [0.75, 0.125, 0.125, 0.75, 0.125, 0.125, 0.25, 0.25, 0.5, 0.5, 0.5]
```
chord函数接收这种新的语法的音名字符串的格式和语法糖和之前写的toNote函数的都是一样的，也是以`;`作为参数之间的分隔符，同样也可以使用小括号，中括号，大括号中的任意一种，参数之间也可以空格，同样也有`.n`表示n分音符的语法糖，参数的顺序为[音符长度;音符间隔;音符音量]，参数的设定同样也是可变的，可以只设置音符长度，或者只设置音符长度和音符间隔，或者3个参数都设置。这个新语法的最大的好处是如果在写一段旋律的时候，有时需要改动其中某个音的音符长度或者某个音和下一个音之间的音符间隔，可以直接在音符名称后面修改，而不需要到音符长度的列表和音符间隔的列表里找到想要修改的音符的位置再修改。chord函数也支持这种新语法的音名字符串的列表。

另外，chord函数的新的语法还有一个独特的语法糖，那就是当音符长度和音符间隔相同的时候，音符间隔可以简写为`.`，而且大家可以在这个简写后面跟上任何加减乘除的运算，比如`.*2`, `./2`，chord函数也会进行计算。当音符间隔简写为`.`的时候，表示音符间隔取和音符长度一样的值。比如
```python
chord('G5[3/4;.], F5[.8;.], E5[.8;.]')
```
插入休止符可以使用`r[音符长度]`的语法作为音符写在字符串中，也可以使用n分音符的语法糖，音符长度的单位为小节，比如
```python
example = chord('G5[3/4;3/4], F5[.8;.8], E5[.8;.8], F5[3/4;1/4], r[.2], E5[.8;.8], D5[.8;.8], E5[.4;.4], D5[.4;.4], C5[.2;.2], B4[.2;.2], G4[.2;.2]')
>>> example
[G5, F5, E5, F5, E5, D5, E5, D5, C5, B4, G4] with interval [0.75, 0.125, 0.125, 0.75, 0.125, 0.125, 0.25, 0.25, 0.5, 0.5, 0.5]
```

## play函数在选择乐器的时候可以用简写
在使用play函数指定乐器演奏的时候，可以用instrument=乐器，现在加入了另一个比较简短的参数，比如演奏a这个和弦类型，可以写
```python
play(a, i=乐器)
```
等价于
```python
play(a, instrument=乐器)
```
## 构建乐曲类型可以使用另一种语法，相对更直观一点
比如现在我们用piece函数构建一个乐曲类型
```python
A1 = C('Cmaj7') % (1, 1/8)
B1 = chord('A2') % (1,)
C1 = chord('C,D,E,F,G') % (1/8, 1/8)
D1 = chord('C5')

new_piece = piece([A1, B1, C1, D1],
                  ['Acoustic Grand Piano', 'Electric Bass (finger)', 'Orchestral Harp', 'Synth Drum'],
                  150,
                  [0, 2, 2, 4],
                  ['piano', 'bass', 'harp', 'drum'])
```
使用`build`函数，可以用另一种语法来构建乐曲类型，这种语法是把一个音轨的所有信息放在一个列表作为第1个轨道，下一个音轨的所有信息放在下一个列表作为第2个轨道，
以此类推，每个音轨的信息的参数的顺序为:  
`[和弦类型, 乐器(可不写), 开始时间(单位为小节)(可不写), 轨道的数字(可不写), 轨道的名字(可不写), 轨道的声相(可不写), 轨道的音量(可不写)]`  
build函数可以接收任意多个音轨的列表，曲速(BPM)默认值为120，指定曲速必须用关键字参数`bpm`，其他的乐曲类型的参数也可以通过关键字参数指定，比如可以写成：
```python
new_piece = build([A1, 'Acoustic Grand Piano', 0, 1, 'piano'],
                  [B1, 'Electric Bass (finger)', 2, 2, 'bass'],
                  [C1, 'Orchestral Harp', 2, 3, 'harp'],
                  [D1, 'Synth Drum', 4, 4, 'drum'],
                  bpm=150)
```
除此之外，build函数也可以接收音轨类型作为参数构建乐曲类型。音轨类型和音轨信息的列表可以混合输入。  
你也可以传入一个元素为音轨类型或者音轨信息的列表(可以混合)的列表，同样也可以构建乐曲类型。
```python
# 使用多个音轨类型构建乐曲类型
new_piece = build(track(A1, instrument='Acoustic Grand Piano', start_time=0, channel=1, track_name='piano'),
                  track(B1, instrument='Electric Bass (finger)', start_time=2, channel=2, track_name='bass'),
                  track(C1, instrument='Orchestral Harp', start_time=2, channel=3, track_name='harp'),
                  track(D1, instrument='Synth Drum', start_time=4, channel=4, track_name='drum'),
                  bpm=150)

# 使用一个音轨类型的列表构建乐曲类型
new_piece = build([track(A1, instrument='Acoustic Grand Piano', start_time=0, channel=1, track_name='piano'),
                  track(B1, instrument='Electric Bass (finger)', start_time=2, channel=2, track_name='bass'),
                  track(C1, instrument='Orchestral Harp', start_time=2, channel=3, track_name='harp'),
                  track(D1, instrument='Synth Drum', start_time=4, channel=4, track_name='drum')],
                  bpm=150)
```

## 得到一个音阶的所有音按照标准音名标记法的列表
在我们表示一个音阶的时候，最常见的比如大调和小调音阶，我们通常会更喜欢用标准音名标记法来表示音阶里的每一个音符，  标准音名标记法就是一个七音的音阶里，  
C D E F G A B这7个字母一定都要出现一次，前面可以搭配升号，降号，重升号，重降号，还原号等等，  只要是等价于音阶里对应的音就行了，  
即使并不是像`A#`, `Eb`这样很自然的有升降号的音也没关系。举个例子，比如Eb大调音阶的音按照标准音名标记法来表示就是
```
Eb, F, G, Ab, Bb, C, D
```
G#大调音阶的音按照标准音名标记法来表示就是
```
G#, A#, B#, C#, D#, E#, Fx
```
在musicpy里面，如果只是普通地用scale函数或者S函数构建音阶，那么这个音阶的音名就都是默认按照database.py里面的标准12音的音名标记法来表示，  
第一个音会按照你输入的音来表示，比如你输入`S('D# major')`第一个音就是`D#`，你输入`S('Eb major')`第一个音就是`Eb`，然后之后的音全部都是只有升号的音，  
比如`S('D# major')`的音是`scale notes: [D#4, F4, G4, G#4, A#4, C5, D5, D#5]`,  
`S('Gb major')`的音是`scale notes: [Gb4, G#4, A#4, B4, C#5, D#5, F5, F#5]`，这样的表示是为了尽量减少在处理音符类型上的运算量，尽量让  
音符名称有且仅有一种，让运算逻辑更加简洁。不过如果你想要得到音阶的按照标准音名标记法的音，可以使用音阶类型的内置函数standard，比如
```python
S('Gb major').standard()
>>> ['Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb', 'F']
S('D# major').standard()
>>> ['D#', 'E#', 'Fx', 'G#', 'A#', 'B#', 'Cx']
S('Eb major').standard()
>>> ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D']
S('C# minor').standard()
>>> ['C#', 'D#', 'E', 'F#', 'G#', 'A', 'B']
S('Ab minor').standard()
>>> ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb']
S('C minor').standard()
>>> ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb']
```
还有relative_note函数，接收两个参数，都是表示音名的字符串，可以返回后面的音名用标准音名标记法表示前面的音名。比如
```python
relative_note('C', 'D')
>>> Dbb
relative_note('A', 'A#')
>>> A♮
relative_note('F', 'E')
>>> E#
relative_note('B', 'C')
>>> Cb
relative_note('G', 'F')
>>> Fx
```

## 得到一段音乐的关于一个调式的负面和声
使用`negative_harmony`函数可以将一个和弦类型转换为指定调式的负面和声，比如现在想把和弦类型a转换为C大调的负面和声，语法为
```python
negtaive_harmony(S('C major'), a)
```
得到的是和弦类型a按照C大调音阶的负面和声转换后的新的和弦类型。
第1个参数是音阶类型，第2个参数是想要进行转换的和弦类型，第3个参数是转换后是否按照音从低到高的顺序重新排列（比如只是转换一个和弦的话，重新排列音高很重要），默认值为False，第4个参数是转换之后是否返回指定的调式的负面和声的映射字典，为True的时候，会直接返回映射字典，不会对和弦类型进行转换，默认值为False。  
此外，第2个参数可以不写，默认值为None，如果在第2个参数不写并且第4个参数为False的时候，会返回指定的调式的负面和声组成的音阶类型，也就是镜像音阶。  
另一种写法是
```python
a.negative_harmony(S('C major'))
```
简写方法是
```python
a @ S('C major')
# 如果有其他参数，可以用元组
a @ (S('C major'), True)
```

## 得到一段音乐的逆行(retrograde)与反行(inversion)
十二音技法里有两个很重要的概念，逆行与反行，具体的定义我在这里不多做描述，大家可以去网上查，这里主要讲怎么写。  
```python
# 和弦类型a的逆行
a.retrograde()
# 和弦类型a的反行
a.pitch_inversion()
# 两者结合着来
a.retrograde().pitch_inversion()
a.pitch_inversion().retrograde()
```
## 下一章 [musicpy的基本语法（五）](https://github.com/Rainbow-Dreamer/musicpy/wiki/musicpy的基本语法（五）)

